# AMQP Publish Subscribe

In the [previous tutorial](https://github.com/dragon13v77/amqp-work-queues) we created a work queue.
The assumption behind a work queue is that each task is delivered to exactly one worker.

In this part we'll do something completely different -- we'll deliver a message to multiple consumers.
This pattern is known as <b>publish/subscribe</b>

### Exchanges

In previous parts of the tutorial we sent and received messages to and from a queue.
Now it's time to introduce the full messaging model in Rabbit.

A <b>producer</b> is a user application that sends messages.
A <b>queue</b> is a buffer that stores messages.
A <b>consumer</b> is a user application that receives messages.

The core idea in the messaging model in RabbitMQ is that the producer never sends any messages directly to a queue.
Actually, quite often the producer doesn't even know if a message will be delivered to any queue at all.

Instead, the producer can only send messages to an <b>exchange</b>.
An exchange is a very simple thing. On one side it receives messages from producers and the other side it pushes them to queues.
That relationship between exchange and a queue is called a binding.


The exchange X must know exactly what to do with a message it receives.
Should it be appended to a particular queue?
Should it be appended to many queues?
Or should it get discarded.
The rules for that are defined by the exchange type.

There are a few exchange types available:

- direct
- topic
- headers
- fanout : it just broadcasts all the messages it receives to all the queues it knows

To create excange:
`ch.assertExchange('exchange_name', 'fanout', {durable: false})`
It just broadcasts all the messages it receives to all the queues it knows.

Recall how we published a message before:
Here we use the default or nameless exchange: messages are routed to the queue with the name specified as first parameter, if it exists.
`channel.sendToQueue('queue_name', Buffer.from('Hello World!'));`

Now, we can publish to our named exchange instead:
`channel.publish('logs_exchange', '', Buffer.from('Hello World!'));`
The empty string as second parameter means that we don't want to send the message to any specific queue.
We want only to publish it to our <b>logs_exchange</b> exchange.

In previous parts of the tutorial we knew nothing about exchanges, but still were able to send messages to queues.
That was possible because we were using a default or nameless exchange, which is identified by the empty string ("").

### Temporary queues

As you may remember previously we were using queues that had specific names.
Being able to name a queue was crucial for us -- we needed to point the workers (message consumers) to the same queue.
Giving a queue a name is important when you want to share the queue between producers and consumers.

Firstly, whenever we connect to Rabbit we need a fresh, empty queue.
To do this we could create a queue with a random name, or, even better - let the server choose a random queue name for us.

Secondly, once we disconnect the consumer the queue should be automatically deleted.

In the amqp.node client, when we supply queue name as an empty string, we create a non-durable queue with a generated name:

>
channel.assertQueue('', {
	exclusive: true
});

When the method returns, the queue instance contains a random queue name generated by RabbitMQ.
For example it may look like `amq.gen-JzTY20BRgKO-HjmUJj0wLg`.
When the connection that declared it closes, the queue will be deleted because it is declared as <b>exclusive</b>.

### Bindings

We've already created a fanout exchange and a queue. Now we need to tell the exchange to send messages to our queue.
That relationship between exchange and a queue is called a binding.

				 ------ binding -----> Q1 -----> C1
	P -------> X
				 ------ binding -----> Q2 -----> C2

`channel.bindQueue('my_queue', 'my_exchange', '');`
From now on the <b>my_exchange</b> exchange will append messages to the queue <b>my_queue</b>.

---

To test start two or more subscribers `node subscriber`.
 Then start publisher `node publish My Message 1` and watch what happens.
 Take a note about queues that are automatically generated by RabbitMQ.
 Because our named exchange is binded to every queue that is generated with each consumer.
 Publishing a message to exchange will distribute that mesaage to every queue because we binded every queye to that exchange.

---
Detail tutorial can be found here https://www.rabbitmq.com/tutorials/tutorial-three-javascript.html